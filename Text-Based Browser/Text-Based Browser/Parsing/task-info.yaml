type: edu
custom_name: stage5
files:
- name: tests.py
  visible: false
  text: |
    from hstest.stage_test import StageTest
    from hstest.test_case import TestCase
    from hstest.check_result import CheckResult

    import os
    import shutil

    import sys
    if sys.platform.startswith("win"):
        import _locale
        # pylint: disable=protected-access
        _locale._getdefaultlocale = (lambda *args: ['en_US', 'utf8'])

    CheckResult.correct = lambda: CheckResult(True, '')
    CheckResult.wrong = lambda feedback: CheckResult(False, feedback)


    class TextBasedBrowserTest(StageTest):

        def generate(self):

            dir_for_files = os.path.join(os.curdir, 'tb_tabs')
            return [
                TestCase(
                    stdin='3.python-requests.org\nexit',
                    attach='requests',
                    args=[dir_for_files]
                ),
                TestCase(
                    stdin='nytimes.com\nnytimes\nexit',
                    attach='The New York Times',
                    args=[dir_for_files]
                ),
                TestCase(
                    stdin='nytimescom\nexit',
                    args=[dir_for_files]
                ),
                TestCase(
                    stdin='bloombergcom\nexit',
                    args=[dir_for_files]
                ),
            ]

        def _check_files(self, path_for_tabs: str, right_word: str) -> bool:
            """
            Helper which checks that browser saves visited url in files and
            provides access to them.

            :param path_for_tabs: directory which must contain saved tabs
            :param right_word: Word-marker which must be in right tab
            :return: True, if right_words is present in saved tab
            """

            path, dirs, filenames = next(os.walk(path_for_tabs))

            for file in filenames:

                with open(os.path.join(path_for_tabs, file), 'r', encoding='utf-8') as tab:
                    content = tab.read()

                    if '</p>' not in content and '</script>' not in content:
                        if '</div>' not in content and right_word in content:
                            return True

            return False

        def check(self, reply, attach):

            # Incorrect URL
            if attach is None:
                if '<p>' in reply:
                    return CheckResult.wrong('You haven\'t checked was URL correct')
                else:
                    return CheckResult.correct()

            # Correct URL
            if isinstance(attach, str):
                right_word = attach

                path_for_tabs = os.path.join(os.curdir, 'tb_tabs')

                if not os.path.isdir(path_for_tabs):
                    return CheckResult.wrong("There are no directory for tabs")

                if not self._check_files(path_for_tabs, right_word):
                    return CheckResult.wrong('There are no correct saved tabs')

                try:
                    shutil.rmtree(path_for_tabs)
                except PermissionError:
                    return CheckResult.wrong("Impossible to remove the directory for tabs. Perhaps you haven't closed some file?")

                if '</p>' not in reply and '</div>' not in reply:
                    if right_word in reply:
                        return CheckResult.correct()

                return CheckResult.wrong('You haven\'t parsed result of request')


    TextBasedBrowserTest('browser.browser').run_tests()
  learner_created: false
- name: browser/browser.py
  visible: true
  text: |
    import sys
    import io
    from pathlib import Path
    import os
    from os import listdir
    from os.path import isfile, join
    import requests


    def is_correct(site_url) -> bool:
        if site_url.count('.') == 0:
            return False
        else:
            return True


    class Stack:
        def __init__(self):
            self.stack = []

        def pop(self) -> str:
            if not self.stack:
                return ''
            else:
                self.stack.pop()
                return self.stack.pop()

        def add(self, value):
            self.stack.append(value)


    class ParseHtml:
        def __init__(self, url):
            self.url = url
            self.format_url()

        def format_url(self):
            if self.url[0:8] != 'https://':
                self.url = 'https://' + self.url

        def get_source(self):
            r = requests.get(self.url)
            return r.text


    class Browser:
        def __init__(self):
            self.dir_path = ""
            self.site_list = []
            self.stack = Stack()

        def create_dir(self):
            if not os.path.exists(self.dir_path):
                Path(self.dir_path).mkdir(parents=True, exist_ok=True)

        def init_site_list(self):
            self.site_list = [f for f in listdir(self.dir_path) if isfile(join(self.dir_path, f))]

        def get_opt(self):
            if len(sys.argv) > 1:
                self.dir_path = sys.argv[1]
                self.create_dir()

        def save_to_dir(self, file_name, data):
            with io.open(self.dir_path + "/" + file_name, "w", encoding="utf-8") as f:
                f.write(data)

        def get_page(self, path):
            with open(self.dir_path + '/' + path) as f:
                for line in f:
                    print(line)

        def run(self):
            self.get_opt()
            self.init_site_list()

            while True:
                command = input()
                short_url = command
                if command == "exit":
                    break
                elif command == "back":
                    self.get_page(self.stack.pop())
                elif is_correct(command):
                    position = short_url.rfind('.')
                    if position >= 0:
                        short_url = short_url[:position]
                    self.site_list.append(short_url)
                    if short_url in set(self.site_list):
                        page = ParseHtml(command)
                        self.save_to_dir(short_url, page.get_source())
                        # self.save_to_dir(short_url, nytimes)
                        self.stack.add(short_url)
                        self.get_page(short_url)
                        pass
                    else:
                        print("Error: Incorrect URL")
                else:
                    print("Error: Incorrect URL")


    if __name__ == "__main__":
        browser = Browser()
        browser.run()
  learner_created: true
- name: browser/dir-for-files/docs.python.txt
  visible: true
  learner_created: true
feedback_link: https://hyperskill.org/projects/79/stages/440/implement
status: Solved
record: 5
